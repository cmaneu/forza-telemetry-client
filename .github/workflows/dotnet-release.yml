name: GitHub Release Publisher

on:
  workflow_dispatch:

permissions:
  contents: write

env:
  # Configuring Project
  PROJECT_PATH: forza-telemetry-client-winui/forza-telemetry-client-winui.csproj
  APP_NAME: forza-telemetry-client-winui
  
  # Check Tag
  CHECK_TAG_EXISTENCE_BEFORE_CREATING_TAG: false
  
  # Custom Nuget Source
  IS_COMMUNITY_TOOLKIT_NUGET_SOURCE_ENABLED: false
  IS_CUSTOM_NUGET_SOURCE_ENABLED: false
  CUSTOM_NUGET_SOURCES: '' # Example ('https://api.nuget.org/v3/index.json, https://api.nuget.org/v2/index.json,...')

  # Configuring Dotnet Build Commands
  PUBLISH_OUTPUT_FOLDER: Publish
  PUBLISH_SELF_CONTAINED: false
  PUBLISH_SINGLE_FILE: false
  PUBLISH_READY_TO_RUN: false
  PUBLISH_AOT: false
  PUBLISH_TRIMMED: false
  PUBLISH_TRIM_MODE: partial # or full

  # Configuring GitHub Release
  IS_PRE_RELEASE: false
  SKIP_IF_RELEASE_EXIST: true
  MAKE_LATEST: true
  ALLOW_UPDATES: false
  ARTIFACT_ERRORS_FAIL_BUILD: false

jobs:
  build:
    runs-on: windows-latest
    outputs: # For accessing them from 'release' job
      app-version: ${{ steps.get-version.outputs.version }}
      base-version: ${{ steps.get-version.outputs.base-version }}
      is-prerelease: ${{ steps.get-version.outputs.is-prerelease }}
    strategy:
      matrix:
        platform: [x64, x86, arm64] # Change platform if you want to build only a specific platform

    steps:
    - uses: actions/checkout@v4
      with:
        submodules: 'true'
        fetch-depth: 0
        
    - uses: actions/setup-dotnet@v4
      with:
       dotnet-version: | 
         8.x.x
         9.x.x

    # Add CommunityToolkit Labs and Main nuget sources
    - run: |
        nuget sources add -name CommunityToolkit-Labs -source https://pkgs.dev.azure.com/dotnet/CommunityToolkit/_packaging/CommunityToolkit-Labs/nuget/v3/index.json
        nuget sources add -name CommunityToolkit-Main -source https://pkgs.dev.azure.com/dotnet/CommunityToolkit/_packaging/CommunityToolkit-MainLatest/nuget/v3/index.json
      if: contains(env.IS_COMMUNITY_TOOLKIT_NUGET_SOURCE_ENABLED, 'true')

    # Add Custom nuget sources
    - run: |
        $sources = $env:CUSTOM_NUGET_SOURCES -split ','
        $trimmedSources = $sources | ForEach-Object { $_.Trim() }
        $prefix = "CUSTOM_SOURCES_"
        for ($i = 0; $i -lt $trimmedSources.Length; $i++) {
          $sourceName = "${prefix}$($i + 1)"
          nuget sources add -name $sourceName -source $trimmedSources[$i]
        }
      if: contains(env.IS_CUSTOM_NUGET_SOURCE_ENABLED, 'true')

    # Determine version based on tags and project file
    - name: Get project version
      uses: kzrnm/get-net-sdk-project-versions-action@v2
      id: get-project-version
      with:
        proj-path: ${{ env.PROJECT_PATH }}
    
    - name: Determine final version
      id: get-version
      shell: pwsh
      run: |
        # Get base version from project file
        $baseVersion = "${{ steps.get-project-version.outputs.version }}"
        $versionSuffix = "${{ steps.get-project-version.outputs.version-suffix }}"
        
        # Try to get latest tag
        $latestTag = ""
        try {
          $latestTag = git describe --tags --abbrev=0 2>$null
          if ($LASTEXITCODE -ne 0) { $latestTag = "" }
        } catch {
          $latestTag = ""
        }
        
        $finalVersion = $baseVersion
        $isPreRelease = $false
        
        # If we have a version suffix (like alpha, beta, etc.), mark as pre-release
        if (![string]::IsNullOrEmpty($versionSuffix)) {
          $finalVersion = "$baseVersion-$versionSuffix"
          $isPreRelease = $true
        }
        # If no tags exist yet, use project version as-is
        elseif ([string]::IsNullOrEmpty($latestTag)) {
          Write-Host "No existing tags found, using project version: $finalVersion"
        }
        # If latest tag is the same as project version, add build metadata
        elseif ($latestTag -eq "v$baseVersion") {
          $commitCount = git rev-list --count HEAD
          $shortSha = git rev-parse --short HEAD
          $finalVersion = "$baseVersion+build.$commitCount.sha.$shortSha"
          Write-Host "Tag already exists for this version, adding build metadata: $finalVersion"
        }
        
        Write-Host "Final version determined: $finalVersion"
        Write-Host "Is pre-release: $isPreRelease"
        
        # Set outputs
        echo "version=$finalVersion" >> $env:GITHUB_OUTPUT
        echo "base-version=$baseVersion" >> $env:GITHUB_OUTPUT
        echo "version-suffix=$versionSuffix" >> $env:GITHUB_OUTPUT
        echo "is-prerelease=$isPreRelease" >> $env:GITHUB_OUTPUT
    
    # Building with configured commands
    - run: |
        $runtimeIdentifier = "${{ matrix.platform }}"
        dotnet publish ${{ env.PROJECT_PATH }} -c Release -r win-$($runtimeIdentifier.ToLower()) /p:GITHUB_ACTIONS=true -p:Platform=${{ matrix.platform }} --self-contained ${{ env.PUBLISH_SELF_CONTAINED }} -p:PublishSingleFile=${{ env.PUBLISH_SINGLE_FILE }} -p:PublishReadyToRun=${{ env.PUBLISH_READY_TO_RUN }} -p:PublishTrimmed=${{ env.PUBLISH_TRIMMED }} -p:TrimMode=${{ env.PUBLISH_TRIM_MODE }} -p:PublishAot=${{ env.PUBLISH_AOT }} --output ${{ env.PUBLISH_OUTPUT_FOLDER }}/${{ matrix.platform }}

    # Zipping folder and all files
    - uses: vimtor/action-zip@v1.2
      with:
        files: ${{ env.PUBLISH_OUTPUT_FOLDER }}/${{ matrix.platform }}
        recursive: true
        dest: ${{ env.APP_NAME }}-v${{ steps.get-version.outputs.version }}-${{ matrix.platform }}.zip

    # Uploading all zip files to access them in the 'release' job
    - uses: actions/upload-artifact@v4
      with:
        name: artifacts-${{ matrix.platform }}
        path: ${{ env.APP_NAME }}-v${{ steps.get-version.outputs.version }}-${{ matrix.platform }}.zip


  release:
    needs: build
    runs-on: ubuntu-latest
    env:
      # Read some variables from the 'build' job
      APP_VERSION: ${{ needs.build.outputs.app-version }}
      BASE_VERSION: ${{ needs.build.outputs.base-version }}
      IS_PRE_RELEASE: ${{ needs.build.outputs.is-prerelease }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Downloading all zip files into the GitHub root directory (uploaded in 'build' job)
      - uses: actions/download-artifact@v4
        with:
          merge-multiple: true

      # Configuring git to create a tag
      - name: Create Git Tag
        run: |
          git config --local user.email "actions@github.com"
          git config --local user.name "GitHub Actions"

          # Use base version for tag name (without build metadata)
          TAG_NAME="v${{ env.BASE_VERSION }}"
          echo "Proposed tag name: $TAG_NAME"
          
          # Always fetch tags to check existence
          git fetch --tags
          
          if [[ "${{ env.CHECK_TAG_EXISTENCE_BEFORE_CREATING_TAG }}" == "true" ]]; then
              if [[ $(git tag -l "$TAG_NAME") ]]; then
                  echo "Tag $TAG_NAME already exists. Skipping tag creation."
                  echo "TAG_CREATED=false" >> $GITHUB_ENV
              else
                  echo "Tag $TAG_NAME not found, creating new tag"
                  git tag "$TAG_NAME"
                  git push origin "$TAG_NAME"
                  echo "TAG_CREATED=true" >> $GITHUB_ENV
              fi
          else
              # For releases with build metadata, we want to create the release but not necessarily a new tag
              if [[ "${{ env.APP_VERSION }}" == *"+"* ]]; then
                  echo "Version contains build metadata. Checking if base tag exists."
                  if [[ $(git tag -l "$TAG_NAME") ]]; then
                      echo "Base tag $TAG_NAME already exists. Using existing tag for release."
                      echo "TAG_CREATED=false" >> $GITHUB_ENV
                  else
                      echo "Base tag $TAG_NAME does not exist. Creating new tag."
                      git tag "$TAG_NAME"
                      git push origin "$TAG_NAME"
                      echo "TAG_CREATED=true" >> $GITHUB_ENV
                  fi
              else
                  echo "Creating new tag $TAG_NAME"
                  git tag "$TAG_NAME"
                  git push origin "$TAG_NAME"
                  echo "TAG_CREATED=true" >> $GITHUB_ENV
              fi
          fi  
          
          echo "TAG_NAME=$TAG_NAME" >> $GITHUB_ENV  
          
      # Installing a package for generating a changelog file
      - run: npm install -g auto-changelog  
      - run: auto-changelog --tag-pattern .+ --commit-limit false --starting-version ${{ env.TAG_NAME }} --ending-version ${{ env.TAG_NAME }} --hide-credit  
      
      # Creating a Release in GitHub
      - uses: ncipollo/release-action@v1
        with:
          artifacts: "${{ env.APP_NAME }}-v${{ env.APP_VERSION }}-*.zip"
          bodyFile: "CHANGELOG.md"
          name: "v${{ env.APP_VERSION }}"
          tag: "${{ env.TAG_NAME }}"
          prerelease: ${{ env.IS_PRE_RELEASE }}
          skipIfReleaseExists: ${{ env.SKIP_IF_RELEASE_EXIST }}
          makeLatest: ${{ env.MAKE_LATEST }}
          allowUpdates: ${{ env.ALLOW_UPDATES }}
          artifactErrorsFailBuild: ${{ env.ARTIFACT_ERRORS_FAIL_BUILD }}



      # - uses: softprops/action-gh-release@v1
      #   with:
      #     name: v${{ env.APP_VERSION }}
      #     tag_name: v${{ env.APP_VERSION }}
      #     body_path: CHANGELOG.md
      #     prerelease: ${{ env.PUBLISH_PRE_RELEASE }}
      #     files: |
      #       ${{ env.APP_NAME }}-v${{ env.APP_VERSION }}-*.zip
